java.lang.AssertionError: assertion failed: bad position: [3647:3621]
occurred in the presentation compiler.

action parameters:
offset: 3621
uri: file://<WORKSPACE>/src/main/scala/forex/Main.scala
text:
package forex

import akka.actor.ActorSystem
import akka.http.scaladsl.server.Route
import forex.config._
import forex.domain._
import forex.interfaces.api.Api
import forex.interfaces.api.rates.RatesApi
import forex.main.HttpServer
import forex.rates.Rates
import forex.services.oneforge.OneForge
import zio.config._
import zio.config.syntax._
import zio.config.typesafe.TypesafeConfigSource
import zio.logging.backend.SLF4J
import zio.{ULayer, ZIOAppDefault, _}
import zio.http.Client
import forex.services.oneforge.OneForgeError
import forex.services.oneforge.ZIOHttpOneForge
import forex.utils.cache.InMemoryCache

object Main extends ZIOAppDefault {

  override def run =
    ZIO.scoped(((HttpServer.start) *> ZIO.never))
      .provide(prepareEnvironment)

  /*
  private def recacheAllIfOptionSet: ZIO[InMemoryCache[Rate.Pair, OneForgeError, Rate] & OptimizationsConfig, Throwable, Unit] =
    for {
      optimizationsConfig <- ZIO.service[OptimizationsConfig]
      ratesCache <- ZIO.service[InMemoryCache[Rate.Pair, OneForgeError, Rate]]
      if (optimizationsConfig.fetchAll)
        pairs: Seq[Rate.Pair] = 
          (
            if (optimizationsConfig.canonicalize) Currency.allKnownPairs.toSeq else Currency.allKnownPairs.flatMap(pair => Seq(pair, pair.swap))
          ).map(tuple => Rate.Pair(tuple._1, tuple._2)).toSeq
        _ <- ratesCache.cacheWithLookup(pairs)
    } yield ()
    */


  private def prepareEnvironment: ZLayer[Any, Throwable, HttpServer & OptimizationsConfig & InMemoryCache[Rate.Pair, _, Rate]] = {

    /* Read configuration and builds the typed object */
    val configLayer =
      ZLayer.fromZIO(read(ApplicationConfig.descriptor.from(TypesafeConfigSource.fromResourcePath))
        .mapBoth(
          err => new RuntimeException(s"Failed to load configuration: $err"),
          identity
        ))

    /* Spawn the actor system, requires a system clock to define timeouts */
    val actorSystemLayer: RLayer[Any, ActorSystem] = {
      val akkaStart = (cfg: AkkaConfig) => ZIO.attempt(ActorSystem(cfg.name))
      val akkaStop  = (sys: ActorSystem, cfg: AkkaConfig) =>
        ZIO.fromFuture(_ => sys.terminate())
          .timeout(cfg.exitJvmTimeout)
          .orDie

      val akkaConfigLayer = configLayer.narrow(_.akka) >>> ZLayer.fromZIO(getConfig[AkkaConfig])

      akkaConfigLayer >>>
        ZLayer.scoped {
          ZIO.service[AkkaConfig].flatMap(config =>
            ZIO.acquireRelease(acquire = akkaStart(config))(release = akkaStop(_, config))
          )
        }
    }

    /* Enriched Logging */
    val loggingLayer: ULayer[Unit] =
      zio.Runtime.removeDefaultLoggers ++ SLF4J.slf4j

    val oneForgeLayer: ZLayer[Any, Throwable, OneForge] = {
      val oneForgeConfigLayer = configLayer.narrow(_.oneForge) >>> ZLayer.fromZIO(getConfig[OneForgeConfig])
      (Client.default ++ oneForgeConfigLayer) >>> OneForge.live
    }

    val optimizationsConfigLayer = configLayer.narrow(_.optimizations) >>> ZLayer.fromZIO(getConfig[OptimizationsConfig])

    val ratesCacheLayer: ZLayer[Any, Throwable, InMemoryCache[Rate.Pair, OneForgeError, Rate]] = 
      ZLayer.fromZIO(
        (for {
          optimizationConfig <- ZIO.service[OptimizationsConfig]
          oneForge <- ZIO.service[OneForge]
          cacheCapacity = optimizationConfig.cacheCapacity(Currency.allKnownPairs.size)
          lookup = 
            (pairs: Seq[Rate.Pair]) => 
              oneForge
                .getMultiple(pairs)
                // The OneForge service fits the 1forge API, where failure to find one of the queried pairs
                // will cause an error.@@
                .map(_.map(Some(_)))
                .catchAll[Any, OneForgeError, Seq[Option[Rate]]](_ => ZIO.succeed(pairs.map(_ => None)))
          cache <- InMemoryCache.make[Rate.Pair, OneForgeError, Rate](cacheCapacity, Some(5.minutes), lookup)
        } yield cache
        ).provideLayer(oneForgeLayer ++ optimizationsConfigLayer)
      )

    /* Build the routes to serve, based on defined services */
    val routesLayer = 
      (oneForgeLayer ++ optimizationsConfigLayer ++ ratesCacheLayer) >>> ({
      val oneForgeRatesLayer = ratesCacheLayer >>> Rates.oneForge
      val ratesApiLayer = oneForgeRatesLayer >>> RatesApi.live
      val apiLayer = ratesApiLayer >>> Api.live

      /* extract routes from the complete API */
      apiLayer >>> ZLayer(ZIO.serviceWith[Api](_.routes))
    })

    val composedLayer = 
      Client.default ++
      actorSystemLayer ++ 
      loggingLayer ++ 
      oneForgeLayer ++ 
      optimizationsConfigLayer ++ 
      ratesCacheLayer ++ 
      routesLayer ++
      configLayer.narrow(_.api)

    /* combine the required layers to start the server */
    //(composedLayer >>> HttpServer.live)
    ???
  }
}



error stacktrace:
scala.reflect.internal.util.Position$.validate(Position.scala:41)
	scala.reflect.internal.util.Position$.range(Position.scala:58)
	scala.reflect.internal.util.InternalPositionImpl.withStart(Position.scala:234)
	scala.reflect.internal.util.InternalPositionImpl.withStart$(Position.scala:135)
	scala.reflect.internal.util.Position.withStart(Position.scala:19)
	scala.meta.internal.pc.CompletionProvider.editRange$lzycompute$1(CompletionProvider.scala:412)
	scala.meta.internal.pc.CompletionProvider.editRange$2(CompletionProvider.scala:411)
	scala.meta.internal.pc.CompletionProvider.expected$1(CompletionProvider.scala:421)
	scala.meta.internal.pc.CompletionProvider.safeCompletionsAt(CompletionProvider.scala:498)
	scala.meta.internal.pc.CompletionProvider.completions(CompletionProvider.scala:58)
	scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$complete$1(ScalaPresentationCompiler.scala:163)
