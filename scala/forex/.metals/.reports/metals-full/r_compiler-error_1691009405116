java.lang.NullPointerException: Cannot invoke "scala.reflect.internal.Types$Type.typeSymbol()" because "tp" is null
occurred in the presentation compiler.

action parameters:
offset: 4491
uri: file://<WORKSPACE>/src/main/scala/forex/rates/RatesCache.scala
text:
package forex.rates

import forex.domain._
import zio.cache.Cache
import java.time.Duration
import zio.cache.Lookup
import zio.{IO, ZIO}
import izumi.reflect.Tag
import java.time.OffsetDateTime
import zio.Ref
import zio.Clock

trait RatesCache[E <: Throwable] extends Cache[Rate.Pair, E, Rate]

object RatesCache {

  trait RateLookup[E <: Throwable] {
    def get(pair: Rate.Pair): IO[E, Rate]
    def getMultiple(pairs: Seq[Rate.Pair]): IO[E, Seq[Rate]]
  }

  def make[E <: Throwable](capacity: Int, timeToLive: Duration)(implicit
  t: Tag[E]): ZIO[RateLookup[E], E, RatesCache[E]] =
    for {
      lookup <- ZIO.service[RateLookup[E]]
      cache  <- Cache.make[Rate.Pair, Any, E, Rate](capacity, timeToLive, Lookup(lookup.get _))
    } yield cache.asInstanceOf[RatesCache[E]]
}

/**
 *  A custom cache for rates, which are stored with a timestamp of last access and an optional staleness timestamp.
 */
class InMemoryCache[Key, Error <: Throwable, Value](
  clock: Clock,
  lookup: (Seq[Key]) => IO[Error, Seq[Option[Value]]],
  capacity: Int,
  timeToLive: Option[Duration],
  ref: Ref[Map[Key, (Value, Option[OffsetDateTime], Option[OffsetDateTime])]]
) {

  private def getStalenessDateTime(timeToLive: Option[Duration], lastFetched: OffsetDateTime): Option[OffsetDateTime] =
    timeToLive.map(ttl => lastFetched.plusNanos(ttl.toNanos))

  private def cleanupStaleEntries(now: OffsetDateTime): ZIO[Any, Nothing, Unit] =
    ref.update { cache =>
      cache.filter { case (_, (_, _, staleDateTime)) => staleDateTime.forall(now.isBefore) }
    }.unit

  // Takes min of `capacity` and `n`, cleans up stale entries, then evicts the least recently accessed entries
  // (or random entries if none are accessed) until the min of `capacity` and `n` is free.
  private def createCapacity(n: Int): ZIO[Any, Nothing, Unit] =
    for {
      now <- clock.currentDateTime
      _   <- cleanupStaleEntries(now)
      _   <- ref.update { cache =>
               val entries        = cache.toSeq.sortBy { case (_, (_, lastAccessTime, _)) => lastAccessTime }
               val entriesToEvict = entries.takeRight(entries.size - n)
               cache -- entriesToEvict.map(_._1)
             }
    } yield ()

  private def remove(keys: Seq[Key]): ZIO[Any, Nothing, Unit] =
    ref.update { cache =>
      cache -- keys
    }.unit

  /**
   * Will maximally cache `capacity` entries, and will evict the least recently used entries first.
   */
  def cache(map: Map[Key, Value]): ZIO[Any, Nothing, Unit] =
    // Take the first `capacity` entries from the map (or the entire map, if it's smaller than `capacity`)
    {
      val mapToCache = map.take(capacity)
      for {
        now                 <- clock.currentDateTime
        alreadyCached       <- ref.get.map(_.filter { case (key, _) => mapToCache.contains(key) })
        (toUpdate, toInsert) = mapToCache.partition { case (key, _) => alreadyCached.contains(key) }
        _                   <- ref.update { cache =>
                                 val mapWithUpdate = toUpdate.foldLeft(cache) { (localCache1, tuple) =>
                                   val (key, value)           = tuple
                                   val (_, lastAccessTime, _) = localCache1(key)
                                   val newStaleDateTime       = getStalenessDateTime(timeToLive, now)
                                   val newEntry               = (value, lastAccessTime, newStaleDateTime)
                                   localCache1 + (key -> newEntry)
                                 }

                                 val mapWithUpdateAndInsert = toInsert.foldLeft(mapWithUpdate) { (localCache2, tuple) =>
                                   val (key, value)     = tuple
                                   val newStaleDateTime = getStalenessDateTime(timeToLive, now)
                                   val newEntry         = (value, None, newStaleDateTime)
                                   localCache2 + (key -> newEntry)
                                 }
                                 cache ++ mapWithUpdateAndInsert
                               }
      } yield ()
    }

  def cacheWithLookup(keys: Seq[Key]): ZIO[Any, Error, Unit] =
    for {
      now     <- clock.currentDateTime
      result  <- lookup(keys)
      zipped   = keys.zip(result)
      filtered = zipped.filter(_._2.isDefined).map(tuple => (tuple._1, tuple._2.get))
      asMap    = filtered.toMap
      _       <- cache(asMap)
    } yield ()

  def recache()@@

  def get(key: Key): ZIO[Any, Error, Option[Value]] =
    for {
      now    <- clock.currentDateTime
      // Try from cache. If not found, try fetching (and re-caching) the value
      result <- ref.get.map(_.get(key)).flatMap {
                  case Some((value, _, staleDateTime)) if staleDateTime.exists(_.isAfter(now)) =>
                    ZIO.succeed(Some(value)).tap(
                      // Update with new last access time
                      _ =>
                        ref.update { cache =>
                          val newEntry = (value, Some(now), staleDateTime)
                          cache + (key -> newEntry)
                        }
                    )

                  case _ => lookup(Seq(key)).map(_.head).tap(value =>
                      if (value.isDefined)
                        ref.update { cache =>
                          val newEntry = (value.get, Some(now), getStalenessDateTime(timeToLive, now))
                          cache + (key -> newEntry)
                        }
                      else
                        ZIO.unit
                    )
                }
    } yield result

  def get(keys: Seq[Key]): ZIO[Any, Error, Seq[Option[Value]]] =
    for {
      now                       <- clock.currentDateTime
      cachedAndFresh            <- ref.get.map(_.filter {
                                     case (key, (_, _, staleDateTime)) =>
                                       staleDateTime.forall(_.isAfter(now)) && keys.contains(key)
                                   })
      (cachedKeys, uncachedKeys) = keys.partition(cachedAndFresh.contains)
      fetched                   <- lookup(uncachedKeys)
      keyValuePairs              = uncachedKeys.zip(fetched)
      filteredPairs              = keyValuePairs.filter(_._2.isDefined)
      asMap                      = filteredPairs.map(tuple => (tuple._1, tuple._2.get)).toMap
      // Cache new entries
      _                         <- cache(asMap)
      // Update last access time for cached entries
      _                         <- ref.update { cache =>
                                     cachedAndFresh.foldLeft(cache) { (localCache, tuple) =>
                                       val (key, (value, _, staleDateTime)) = tuple
                                       val newEntry                         = (value, Some(now), staleDateTime)
                                       localCache + (key -> newEntry)
                                     }
                                   }
      // Map the original seq of keys to a seq of optional values
      result                     = keys.map(key => cachedAndFresh.get(key).map(_._1) orElse asMap.get(key))
    } yield result

}



error stacktrace:
scala.reflect.internal.Definitions$DefinitionsClass.isByNameParamType(Definitions.scala:422)
	scala.reflect.internal.TreeInfo.isStableIdent(TreeInfo.scala:140)
	scala.reflect.internal.TreeInfo.isStableIdentifier(TreeInfo.scala:113)
	scala.reflect.internal.TreeInfo.isPath(TreeInfo.scala:102)
	scala.tools.nsc.interactive.Global.stabilizedType(Global.scala:974)
	scala.tools.nsc.interactive.Global.typedTreeAt(Global.scala:822)
	scala.meta.internal.pc.SignatureHelpProvider.signatureHelp(SignatureHelpProvider.scala:23)
	scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$signatureHelp$1(ScalaPresentationCompiler.scala:276)
