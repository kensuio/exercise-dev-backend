id: file://<WORKSPACE>/src/main/scala/forex/rates/RatesCache.scala:[2702..2703) in Input.VirtualFile("file://<WORKSPACE>/src/main/scala/forex/rates/RatesCache.scala", "package forex.rates

import forex.domain._
import zio.cache.Cache
import java.time.Duration
import zio.cache.Lookup
import zio.{ZIO, IO}
import izumi.reflect.Tag
import java.time.OffsetDateTime
import zio.Ref
import zio.Clock

trait RatesCache[E <: Throwable] extends Cache[Rate.Pair, E, Rate]

object RatesCache {

    trait RateLookup[E <: Throwable] {
        def get(pair: Rate.Pair): IO[E, Rate]
        def getMultiple(pairs: Seq[Rate.Pair]): IO[E, Seq[Rate]]
    }

    def make[E <: Throwable](capacity: Int, timeToLive: Duration)(implicit t: Tag[E]): ZIO[RateLookup[E], E, RatesCache[E]] = 
        for {
            lookup <- ZIO.service[RateLookup[E]]
            cache <- Cache.make[Rate.Pair, Any, E, Rate](capacity, timeToLive, Lookup(lookup.get _))
        } yield cache.asInstanceOf[RatesCache[E]]
}


/**
  *  A custom cache for rates, which are stored with a timestamp of last access and an optional staleness timestamp.
  */
class InMemoryCache[Key, Value, Error <: Throwable](
    clock: Clock,
    lookup: (Seq[Key]) => IO[Error, Seq[Value]], 
    capacity: Int, 
    timeToLive: Option[Duration], 
    ref: Ref[Map[Key, (Value, Option[OffsetDateTime], Option[OffsetDateTime])]]
) {
    import zio._
    import zio.stm._
    import zio.ZIO._

    private def getStalenessDateTime(timeToLive: Option[Duration], lastFetched: OffsetDateTime): Option[OffsetDateTime] = 
        timeToLive.map(ttl => lastFetched.plusNanos(ttl.toNanos))
    
    def cache(keys: Seq[Key]): ZIO[Any, Error, Unit] = 
        for {
            now <- clock.currentDateTime
            values <- lookup(keys)
            staleDateTime = getStalenessDateTime(timeToLive, now)
            
            // Update ref with new map as follows:
            // 1. Zip the keys with the values
            // 2. Go through the zipped tuples
            // 3. For each entry, check by the key if it's already in the cache
            //    3.1. If it is, take the existing time of last access and set a new staleness-time
            //    2.2. If it isn't, create a new entry with `None` as a time of last access and a new staleness-time 
            _  <- ref.update { cache => 
                keys.zip(values).foldLeft(cache) { (cache, tuple) => 
                    val (key, value) = tuple
                    val existing = cache.get(key)
                    val newLastFetched = if (existing.isDefined) existing.get._2 else None
                    val newStaleDateTime = getStalenessDateTime(timeToLive, now)
                    val newEntry = (value, newLastFetched, newStaleDateTime)
                    cache + (key -> newEntry)
                }
            }
        } yield ()
    
    def 
    
    
}")
file://<WORKSPACE>/src/main/scala/forex/rates/RatesCache.scala:74: error: expected identifier; obtained rbrace
}
^